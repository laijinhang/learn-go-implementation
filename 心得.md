第二十三天（2020.03.26）
学习到的内容：
1、加深 strings.LastIndex(s1, s2) int 的使用，该方法是返回s2在s1中第一次出现的位置，如果没有找到，则返回-1
2、continue的高级用法，如下所示

// 它会直接跳出内层循环，等价于使用了 break
package main

import "fmt"

func main() {
CMD:
    for i := 0;i < 3;i++ {
        for j := 10;j < 20;j++ {
            fmt.Println(i)
            continue CMD
        }
    }
}
// 输出：
0
1
2
3、flag.FlagSet知识
第十六天（2020.02.10）
这个项目的难度有以下几点

它可能需要长达很多个月看不到效果，这对于在现实中习惯了快速开发（几分钟写完一个接口，然后看到测试成功的效果图）或习惯了生活中的快刺激（如抖音里几分钟或者十多秒获得快乐体验，游戏等）的人是一个极大的挑战
它是一个全新的内容和知识，可能从来都没有见过的
它已经迭代了十多年时间
它涵盖了计算机中一个非常复杂的内容，编译器实现
第十五天（2020.02.09）
build
目前实现，没有任何命令模块加入

官方实现的go源码，已加载了go工具命令，接下来开发是将build，这个命令加载上去，这个命令涉及到go编译器实现的实战，是迄今为止我所遇到的最大难度挑战

第十四天（2020.02.08）
虽然这些代码我都没接触过，但不断接触这些源码，才能让自己成长
第十三天（2020.02.07）源码
goland debug追踪

go mod
学习到的内容：
1. go mod，里面看到一个关于禁止Git提示输入密码设置。仅对2.3.0或更高版本有效，环境变量GIT_TERMINAL_PROMPT=1为显示
2. 今天接触到的比较多的是关于go mod的实现，这一块内容，学习到go mod是如何实现Git的相关设置
感悟
1. 当你知道细节之后，你就可以避免去阅读和理解大量第三方文章之后然而还是一知半解的状态，从而可以提升效率和节省大量时间精力
2. （阅读）和（理解每一行，然后码一遍代码，让它跑起来），这两种收获是有非常大的区别的

我本来是写 go version 的，结果跟着源码走，写到 go mod 的实现了

感受：一开始，带着学习的心态，然后看到一个新的东西，一脸懵逼，然后把它搞懂，对于源码级的代码会有一种实实在在的踏实感，然后就不想继续写代码

第三天（2020.01.28）

实现 go version
实现 go env
学习到的内容：
1. 了解到filepath包，发现递归扫描目录可以这么简单的方式去实现
2. go version命令的实现以及更熟练的使用，go version：输出版本，go version 目录：递归输出所有go程序的版本信息，go version 文件名：输出这个文件的程序信息
3. 怎么去判断一个编译后的文件是不是go程序，并且读取是哪个版本的程序，dos、类unix、mac、aix四个平台
问题：
引入："internal/cfg"，报错。Use of internal package is not allowed ，这个包不能被引入，所以只能是将包拷贝出来一份

第二天（2020.01.27）
实现打印命令说明剩下内容
1.png
这是已经完成的内容，然后明天计划将go env和go version命令实现，这两个比较简单

学习到的内容：体会到 text/template 可以被这样灵活应用到命令工具中

第一天（2020.01.26）
实现打印命令说明
学习到的内容：项目目录结构